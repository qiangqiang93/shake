{"remainingRequest":"/Users/qiang/work/hytx/hytx-rebuild/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/qiang/work/hytx/hytx-rebuild/src/module/common/cropper/index.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/qiang/work/hytx/hytx-rebuild/src/module/common/cropper/index.vue","mtime":1546945723962},{"path":"/Users/qiang/work/hytx/hytx-rebuild/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/qiang/work/hytx/hytx-rebuild/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/qiang/work/hytx/hytx-rebuild/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/qiang/work/hytx/hytx-rebuild/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nimport Cropper from 'cropperjs'\nimport { getOssConfig } from '@/utils'\nimport { mapState, mapActions } from 'vuex'\nimport eventBus from '../../../utils/eventBus'\nimport httpService from '@/service/httpService'\nimport dialogService from '../../../service/dialogService.js'\n\nexport default {\n  data() {\n    return {\n      edit: false, // 编辑状态\n      cropper: null, // 裁剪器\n      editing: false // 编辑中\n    }\n  },\n  mounted() {\n    if (!this.input) this.$router.back()\n  },\n  methods: {\n    ...mapActions(['system/updateCropper']),\n    // 裁剪初始化\n    crop() {\n      if (!this.input) return\n      let element = document.querySelector('#cropper')\n      this.cropper = new Cropper(element, {\n        viewMode: 2,\n        modal: false,\n        autoCropArea: 1,\n        dragMode: 'move',\n        aspectRatio: this.input.ratio || ''\n      })\n    },\n    // 上传原图\n    uploadOrigin() {\n      if (this.input.file.length < 100 * 1024) {\n        this.uploadImg(this.input.file)\n      } else {\n        this.compress(this.input.file)\n      }\n    },\n    // 裁剪切换/取消\n    toggleEdit(input) {\n      this.edit = input\n      if (input) {\n        this.editing = input\n        setTimeout(() => {\n          this.crop()\n        }, 410)\n      } else {\n        if (this.cropper) {\n          this.cropper.destroy()\n          this.cropper = null\n          setTimeout(() => {\n            // this.editing = input\n          }, 400)\n        }\n      }\n    },\n    // 旋转图片并解决旋转位置错误的bug\n    rotate() {\n      //get data\n      let data = this.cropper.getCropBoxData()\n      let contData = this.cropper.getContainerData()\n      //set data of cropbox to avoid unwanted behavior due to strict mode\n      data.top = 0\n      data.width = 2\n      data.height = 2\n      data.left = contData.width / 2 - 1\n      this.cropper.setCropBoxData(data)\n      //rotate\n      this.cropper.rotate(90)\n      //get canvas data\n      let canvData = this.cropper.getCanvasData()\n      //calculate new height and width based on the container dimensions\n      let heightOld = canvData.height\n      let heightNew = contData.height\n      let koef = heightNew / heightOld\n      let widthNew = canvData.width * koef\n      canvData.width = widthNew\n      canvData.height = heightNew\n      canvData.top = 0\n      if (canvData.width >= contData.width) {\n        canvData.left = 0\n      } else {\n        canvData.left = (contData.width - canvData.width) / 2\n      }\n      this.cropper.setCanvasData(canvData)\n      //and now set cropper \"back\" to full crop\n      data.left = 0\n      data.top = 0\n      data.width = canvData.width\n      data.height = canvData.height\n      this.cropper.setCropBoxData(data)\n    },\n    // 裁剪图片\n    cropHandler() {\n      let img = this.cropper.getCroppedCanvas()\n      img = img.toDataURL()\n      if (img.length < 100 * 1024) {\n        this.uploadImg(img)\n      } else {\n        this.compress(img)\n      }\n    },\n    // 压缩图片\n    compress(input) {\n      let _self = this\n      let image = new Image()\n      image.src = input\n      image.onload = function() {\n        let canvas = document.createElement('canvas')\n        let ctx = canvas.getContext('2d')\n        // 瓦片canvas\n        let tCanvas = document.createElement('canvas')\n        let tctx = tCanvas.getContext('2d')\n        let initSize = image.src.length\n        let width = image.width\n        let height = image.height\n        // 如果图片大于四百万像素，计算压缩比并将大小压至400万以下\n        let ratio\n        if ((ratio = (width * height) / 4000000) > 1) {\n          ratio = Math.sqrt(ratio)\n          width /= ratio\n          height /= ratio\n        } else {\n          ratio = 1\n        }\n        canvas.width = width\n        canvas.height = height\n        // 铺底色\n        ctx.fillStyle = '#fff'\n        ctx.fillRect(0, 0, canvas.width, canvas.height)\n        // 如果图片像素大于100万则使用瓦片绘制\n        let count\n        if ((count = (width * height) / 1000000) > 1) {\n          count = ~~(Math.sqrt(count) + 1) // 计算要分成多少块瓦片\n          // 计算每块瓦片的宽和高\n          let nw = ~~(width / count)\n          let nh = ~~(height / count)\n          tCanvas.width = nw\n          tCanvas.height = nh\n          for (let i = 0; i < count; i++) {\n            for (let j = 0; j < count; j++) {\n              tctx.drawImage(\n                image,\n                i * nw * ratio,\n                j * nh * ratio,\n                nw * ratio,\n                nh * ratio,\n                0,\n                0,\n                nw,\n                nh\n              )\n              ctx.drawImage(tCanvas, i * nw, j * nh, nw, nh)\n            }\n          }\n        } else {\n          ctx.drawImage(image, 0, 0, width, height)\n        }\n        // 进行最小压缩\n        let ndata = canvas.toDataURL('image/jpeg', 0.8)\n        _self.uploadImg(ndata)\n      }\n    },\n    // base64转blob\n    dataURLtoBlob(dataurl) {\n      var arr = dataurl.split(','),\n        mime = arr[0].match(/:(.*?);/)[1],\n        bstr = atob(arr[1]),\n        n = bstr.length,\n        u8arr = new Uint8Array(n)\n      while (n--) {\n        u8arr[n] = bstr.charCodeAt(n)\n      }\n      return new Blob([u8arr], { type: mime })\n    },\n    // 上传图片\n    async uploadImg(data) {\n      if (this.ossConfig) {\n        let filename =\n          new Date().getTime() + '_' + parseInt(Math.random() * 1000000)\n        let suffix = data.match(/data:image\\/([a-z]+);base64/)[1]\n        let formData = new FormData()\n        formData.append('key', this.ossConfig.dir + filename + '.' + suffix)\n        formData.append('file', this.dataURLtoBlob(data))\n        formData.append('name', filename + '.' + suffix)\n        formData.append('success_action_status', 200)\n        formData.append('policy', this.ossConfig.policy)\n        formData.append('signature', this.ossConfig.signature)\n        formData.append('OSSAccessKeyId', this.ossConfig.accessid)\n        try {\n          await httpService({\n            method: 'post',\n            url: this.ossConfig.host,\n            headers: {\n              Authorization: '',\n              'Content-Type': 'multipart/form-data'\n            },\n            body: formData\n          })\n          let url = `${this.ossConfig.host}/${this.ossConfig.dir +\n            filename}.${suffix}`\n          eventBus.$emit(this.input.eventName, url)\n          this.$router.back()\n        } catch (err) {\n          dialogService.alert(err.message)\n        }\n      } else {\n        await getOssConfig()\n        this.uploadImg(data)\n      }\n    }\n  },\n  computed: {\n    ...mapState({\n      input: state => state.system.cropper,\n      ossConfig: state => state.system.ossConfig\n    })\n  },\n  destroyed() {\n    if (this.cropper) {\n      this.cropper.destroy()\n    }\n    this['system/updateCropper'](null)\n  }\n}\n",{"version":3,"sources":["index.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmCA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.vue","sourceRoot":"src/module/common/cropper","sourcesContent":["<!--\n    @name           cropper\n    @desc           图片裁剪组件(页面级)\n                    数据来源vuex \n    @props\n                    input: {\n                        file        base64图片\n                        ratio       图片裁剪比例\n                        eventName   dispatch事件名\n                    }\n    @emit           \n        eventName   props.eventName\n        path        path            上传成功后的路径\n-->\n\n<template>\n  <div class=\"cropper-wrapper\">\n    <div class=\"cropper-contain\" :class=\"{'edit': edit}\">\n      <img :src=\"input.file || ''\" :class=\"{'edit': editing}\" alt=\"\" id=\"cropper\">\n    </div>\n    <div class=\"cropper-footer\">\n      <template v-if=\"edit\">\n        <span class=\"iconfont icon-cuo3\" @click=\"toggleEdit(false)\"></span>\n        <span class=\"iconfont icon-xuanzhuan\" @click=\"rotate()\"></span>\n        <span class=\"iconfont icon-dagou1\" @click=\"cropHandler()\"></span>\n      </template>\n      <template v-else>\n        <span @click=\"toggleEdit(true)\">编辑</span>\n        <span @click=\"uploadOrigin()\">上传原图</span>\n      </template>\n    </div>\n  </div>\n</template>\n\n<script>\nimport Cropper from 'cropperjs'\nimport { getOssConfig } from '@/utils'\nimport { mapState, mapActions } from 'vuex'\nimport eventBus from '../../../utils/eventBus'\nimport httpService from '@/service/httpService'\nimport dialogService from '../../../service/dialogService.js'\n\nexport default {\n  data() {\n    return {\n      edit: false, // 编辑状态\n      cropper: null, // 裁剪器\n      editing: false // 编辑中\n    }\n  },\n  mounted() {\n    if (!this.input) this.$router.back()\n  },\n  methods: {\n    ...mapActions(['system/updateCropper']),\n    // 裁剪初始化\n    crop() {\n      if (!this.input) return\n      let element = document.querySelector('#cropper')\n      this.cropper = new Cropper(element, {\n        viewMode: 2,\n        modal: false,\n        autoCropArea: 1,\n        dragMode: 'move',\n        aspectRatio: this.input.ratio || ''\n      })\n    },\n    // 上传原图\n    uploadOrigin() {\n      if (this.input.file.length < 100 * 1024) {\n        this.uploadImg(this.input.file)\n      } else {\n        this.compress(this.input.file)\n      }\n    },\n    // 裁剪切换/取消\n    toggleEdit(input) {\n      this.edit = input\n      if (input) {\n        this.editing = input\n        setTimeout(() => {\n          this.crop()\n        }, 410)\n      } else {\n        if (this.cropper) {\n          this.cropper.destroy()\n          this.cropper = null\n          setTimeout(() => {\n            // this.editing = input\n          }, 400)\n        }\n      }\n    },\n    // 旋转图片并解决旋转位置错误的bug\n    rotate() {\n      //get data\n      let data = this.cropper.getCropBoxData()\n      let contData = this.cropper.getContainerData()\n      //set data of cropbox to avoid unwanted behavior due to strict mode\n      data.top = 0\n      data.width = 2\n      data.height = 2\n      data.left = contData.width / 2 - 1\n      this.cropper.setCropBoxData(data)\n      //rotate\n      this.cropper.rotate(90)\n      //get canvas data\n      let canvData = this.cropper.getCanvasData()\n      //calculate new height and width based on the container dimensions\n      let heightOld = canvData.height\n      let heightNew = contData.height\n      let koef = heightNew / heightOld\n      let widthNew = canvData.width * koef\n      canvData.width = widthNew\n      canvData.height = heightNew\n      canvData.top = 0\n      if (canvData.width >= contData.width) {\n        canvData.left = 0\n      } else {\n        canvData.left = (contData.width - canvData.width) / 2\n      }\n      this.cropper.setCanvasData(canvData)\n      //and now set cropper \"back\" to full crop\n      data.left = 0\n      data.top = 0\n      data.width = canvData.width\n      data.height = canvData.height\n      this.cropper.setCropBoxData(data)\n    },\n    // 裁剪图片\n    cropHandler() {\n      let img = this.cropper.getCroppedCanvas()\n      img = img.toDataURL()\n      if (img.length < 100 * 1024) {\n        this.uploadImg(img)\n      } else {\n        this.compress(img)\n      }\n    },\n    // 压缩图片\n    compress(input) {\n      let _self = this\n      let image = new Image()\n      image.src = input\n      image.onload = function() {\n        let canvas = document.createElement('canvas')\n        let ctx = canvas.getContext('2d')\n        // 瓦片canvas\n        let tCanvas = document.createElement('canvas')\n        let tctx = tCanvas.getContext('2d')\n        let initSize = image.src.length\n        let width = image.width\n        let height = image.height\n        // 如果图片大于四百万像素，计算压缩比并将大小压至400万以下\n        let ratio\n        if ((ratio = (width * height) / 4000000) > 1) {\n          ratio = Math.sqrt(ratio)\n          width /= ratio\n          height /= ratio\n        } else {\n          ratio = 1\n        }\n        canvas.width = width\n        canvas.height = height\n        // 铺底色\n        ctx.fillStyle = '#fff'\n        ctx.fillRect(0, 0, canvas.width, canvas.height)\n        // 如果图片像素大于100万则使用瓦片绘制\n        let count\n        if ((count = (width * height) / 1000000) > 1) {\n          count = ~~(Math.sqrt(count) + 1) // 计算要分成多少块瓦片\n          // 计算每块瓦片的宽和高\n          let nw = ~~(width / count)\n          let nh = ~~(height / count)\n          tCanvas.width = nw\n          tCanvas.height = nh\n          for (let i = 0; i < count; i++) {\n            for (let j = 0; j < count; j++) {\n              tctx.drawImage(\n                image,\n                i * nw * ratio,\n                j * nh * ratio,\n                nw * ratio,\n                nh * ratio,\n                0,\n                0,\n                nw,\n                nh\n              )\n              ctx.drawImage(tCanvas, i * nw, j * nh, nw, nh)\n            }\n          }\n        } else {\n          ctx.drawImage(image, 0, 0, width, height)\n        }\n        // 进行最小压缩\n        let ndata = canvas.toDataURL('image/jpeg', 0.8)\n        _self.uploadImg(ndata)\n      }\n    },\n    // base64转blob\n    dataURLtoBlob(dataurl) {\n      var arr = dataurl.split(','),\n        mime = arr[0].match(/:(.*?);/)[1],\n        bstr = atob(arr[1]),\n        n = bstr.length,\n        u8arr = new Uint8Array(n)\n      while (n--) {\n        u8arr[n] = bstr.charCodeAt(n)\n      }\n      return new Blob([u8arr], { type: mime })\n    },\n    // 上传图片\n    async uploadImg(data) {\n      if (this.ossConfig) {\n        let filename =\n          new Date().getTime() + '_' + parseInt(Math.random() * 1000000)\n        let suffix = data.match(/data:image\\/([a-z]+);base64/)[1]\n        let formData = new FormData()\n        formData.append('key', this.ossConfig.dir + filename + '.' + suffix)\n        formData.append('file', this.dataURLtoBlob(data))\n        formData.append('name', filename + '.' + suffix)\n        formData.append('success_action_status', 200)\n        formData.append('policy', this.ossConfig.policy)\n        formData.append('signature', this.ossConfig.signature)\n        formData.append('OSSAccessKeyId', this.ossConfig.accessid)\n        try {\n          await httpService({\n            method: 'post',\n            url: this.ossConfig.host,\n            headers: {\n              Authorization: '',\n              'Content-Type': 'multipart/form-data'\n            },\n            body: formData\n          })\n          let url = `${this.ossConfig.host}/${this.ossConfig.dir +\n            filename}.${suffix}`\n          eventBus.$emit(this.input.eventName, url)\n          this.$router.back()\n        } catch (err) {\n          dialogService.alert(err.message)\n        }\n      } else {\n        await getOssConfig()\n        this.uploadImg(data)\n      }\n    }\n  },\n  computed: {\n    ...mapState({\n      input: state => state.system.cropper,\n      ossConfig: state => state.system.ossConfig\n    })\n  },\n  destroyed() {\n    if (this.cropper) {\n      this.cropper.destroy()\n    }\n    this['system/updateCropper'](null)\n  }\n}\n</script>\n\n<style>\n@import url('./cropper.css');\n</style>\n\n<style lang=\"scss\" scoped>\n.cropper-wrapper {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 9999;\n  display: flex;\n  position: fixed;\n  overflow: hidden;\n  background: #000;\n  flex-direction: column;\n}\n.cropper-contain {\n  flex: 1;\n  width: 100%;\n  height: 100%;\n  display: flex;\n  overflow: auto;\n  align-items: center;\n  justify-content: center;\n  transition: all ease 0.4s;\n  &::-webkit-scrollbar {\n    display: none;\n  }\n  -webkit-overflow-scrolling: touch;\n  &.edit {\n    height: calc(100% - 110px);\n    margin-bottom: 110px;\n  }\n}\n#cropper {\n  width: 100%;\n  transition: all ease 0.4s;\n  &.edit {\n    width: unset;\n    max-width: 100%;\n    max-height: 100%;\n  }\n}\n.cropper-footer {\n  bottom: 0;\n  width: 100%;\n  height: 100px;\n  color: #fff;\n  display: flex;\n  font-size: 32px;\n  padding: 0 25px;\n  line-height: 100px;\n  position: absolute;\n  align-items: center;\n  box-sizing: border-box;\n  justify-content: space-between;\n  font-family: 'PingFang SC Medium';\n  background: rgba(19, 31, 43, 0.6);\n  .iconfont {\n    font-size: 48px;\n  }\n}\n</style>\n"]}]}